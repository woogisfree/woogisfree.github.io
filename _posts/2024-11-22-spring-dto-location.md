---
title: 'DTO는 어디에서 처리해야 할까?'
excerpt: ''

categories:
  - Spring
tags:
  - [tag1, tag2]

permalink: /spring/dto/

toc: true
toc_sticky: true

date: 2024-11-23
last_modified_at: 2024-11-23
---

## 이 글을 쓰게 된 계기

사이드 프로젝트를 진행하던 중, 클라이언트의 요청을 처리하기 위해 DTO를 사용하던 상황이 있었습니다. 데이터를 주고받는 과정에서 `DTO <-> Entity 변환 로직은 어디에서 처리하는게 가장 좋을까?` 라는 고민이 생겼습니다.

처음에는 컨트롤러에서 처리하는 것이 간단하다고 생각했지만, 코드가 점점 복잡해지면서 DTO 변환 로직이 컨트롤러에 섞이는 것이 마음에 들지 않았습니다. 결국 서비스 레이어와 레포지토리에서도 변환 로직을 처리할 가능성을 고민하며, 각 방식의 장단점을 정리하게 되었습니다.

이 글은 제가 직접 겪었던 고민과 그 해결 과정을 바탕으로, DTO와 Entity 변환 로직을 처리할 최적의 위치를 찾는 데 도움을 드리고자 작성했습니다.

## DTO란?

애플리케이션 개발을 하다 보면 데이터를 주고받기 위해 `DTO(Data Transfer Object)` 라는 용어를 자주 접하게 됩니다.

DTO는 계층 간 데이터 교환을 목적으로 사용하는 객체로, 일반적으로 아래와 같은 역할을 합니다.
- Request DTO: 클라이언트가 서버에 데이터를 보낼 때 사용하는 객체. 주로 입력 데이터의 유효성 검증이나 클라이언트-서버 간 데이터 포맷을 표준화하는 데 사용됩니다.
- Response DTO: 서버가 클라이언트로 데이터를 보낼 때 사용하는 객체. 주로 응답 데이터의 포맷을 정의하거나, 민감한 정보를 숨기기 위해 사용됩니다.

DTO는 Entity와 유사하게 보일 수 있지만, 둘은 명확하게 구분되어야 합니다.
- Entity: 데이터베이스와 직접적으로 매핑되는 객체. 주로 JPA, Hibernate 등 ORM에서 사용됩니다.
- DTO: 애플리케이션 내부의 특정 계층 간 데이터를 주고받는 데 사용되며, 데이터베이스와의 직접적인 연관은 없습니다.

## DTO 변환을 어디에서 처리해야 할까?

DTO와 Entity 간의 변환을 어디에서 처리할지에 따라 애플리케이션의 유지보수성, 가독성, 확장성이 달라질 수 있습니다. 이번에는 변환 로직을 컨트롤러, 서비스, 레포지토리 중 어디에 두는게 좋을 지 각각의 장단점을 살펴보겠습니다.

### 1. 컨트롤러 (Controller, Presentation Layer) 에서 변환

컨트롤러는 HTTP 요청과 응답을 처리하는 레이어입니다. 이 레이어에서 DTO 변환을 처리하면 다음과 같은 장단점이 있습니다.

#### 장점
- 변환 로직이 직관적이고 단순한 경우 처리 속도가 빠릅니다.
- 변환 작업이 요청과 응답의 흐름에서 명시적으로 드러납니다.

#### 단점
- 컨트롤러의 역할은 요청을 처리하고 적절한 서비스를 호출하는 데 집중해야 합니다. 변환 로직이 컨트롤러에 추가되면 `단일 책임 원칙(SRP)` 을 위반할 가능성이 큽니다.
- 복잡한 변환 로직이 컨트롤러에 포함되면 코드가 비대해지고 가독성이 떨어질 수 있습니다.

### 2. 서비스 (Service, Business Layer) 에서 변환

서비스는 애플리케이션의 비즈니스 로직을 처리하는 핵심 계층입니다. DTO 변환을 서비스 레이어에서 처리하는 경우가 가장 일반적입니다.

#### 장점
- DTO 변환 로직이 비즈니스 로직과 함께 관리되므로 자연스럽게 코드가 응집됩니다.
- 컨트롤러가 가벼워지고 역할이 분리되어 코드 가독성이 향상됩니다.
- 변환 로직을 별도의 유틸리티 클래스나 매퍼(MapStruct, ModelMapper 등)로 분리하면, 다른 서비스에서도 재사용이 가능합니다.

#### 단점
- 복잡한 변환 로직이 많아질 경우 서비스 코드가 다소 비대해질 수 있습니다.

### 3. 레포지토리 (Repository, Persistence Layer) 에서 변환

레포지토리는 데이터베이스와 직접적으로 상호작용하는 계층입니다. 이곳에서 DTO 변환을 수행하면 데이터베이스 조회 시 필요한 데이터를 필터링하거나 프로젝션(Projection) 으로 직접 DTO를 반환할 수 있습니다.

#### 장점
- 데이터베이스 조회 시 필요한 필드만 매핑하여 성능을 최적화할 수 있습니다.
- 복잡한 SQL 쿼리나 프로젝션(QueryDSL, JPQL)을 통해 DTO를 직접 생성하면 별도의 변환 로직이 필요 없습니다.

#### 단점
- 레포지토리의 주요 역할은 데이터베이스와의 상호작용입니다. DTO 변환 로직이 포함되면 `단일 책임 원칙(SRP)`을 위반할 가능성이 큽니다.
- 특정 DTO에 종속된 레포지토리는 다른 사용 사례에 적합하지 않을 수 있어 확장성이 떨어집니다.
- 비즈니스 로직이 레포지토리로 분산되어 유지보수가 어려워질 수 있습니다.

## 최종 결론: 어디에 두는 것이 적합한가?

- 일반적인 권장사항
    - DTO ↔ Entity 변환은 `서비스`에서 처리하는 것이 가장 이상적입니다.
    - 서비스는 비즈니스 로직과 데이터 변환을 한곳에서 처리하기에 적합하며, 컨트롤러와 레포지토리를 가볍게 유지할 수 있습니다.

- 예외적인 경우
  - 컨트롤러: 변환 로직이 단순하고 재사용 가능성이 없는 경우.
  - 레포지토리: 데이터베이스 쿼리 성능 최적화를 위해 DTO를 직접 반환해야 하는 경우.

### 추천 아키텍처

**컨트롤러(Controller, Presentation Layer)**
- 요청(Request) DTO를 서비스로 전달.
- 서비스에서 반환된 결과를 응답(Response) DTO로 변환.

**서비스(Service, Business Layer)**
- 비즈니스 로직 수행.
- Entity ↔ DTO 변환.

**레포지토리(Repository, Persistence Layer)**
- Entity를 반환 (필요 시 QueryDSL, JPQL, Projections 등을 활용해 최적화)

이 구조를 따르면 각 레이어의 책임을 명확히 분리하면서도 코드의 가독성과 유지보수성을 높일 수 있습니다.

---
부록: DTO 변환 자동화 도구
- 복잡한 DTO 변환 로직을 자동화하려면 아래 도구들을 사용하는 것을 고려해볼 수 있습니다:
    - `MapStruct`: 컴파일 타임에 DTO 매핑 코드를 생성.
    - `ModelMapper`: 런타임 매핑으로 간단한 설정으로 동작.
    - `Lombok의 @Builder`: 빌더 패턴을 사용해 수동으로 매핑할 때 유용.

이 글을 통해 DTO 변환에 대한 고민을 덜고, 더 나은 설계 결정을 내리는 데 도움이 되었길 바랍니다😊
